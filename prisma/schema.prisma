generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String        @id @default(cuid())
  email               String        @unique
  phone               String        @unique
  firstName           String?
  lastName            String?
  gender              Gender
  dateOfBirth         DateTime
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt
  passcode            String
  bvn                 String?       @unique
  isVerified          Boolean       @default(false)
  isOnboarded         Boolean       @default(false)
  kycStatus           KycStatus     @default(PENDING)
  kycVerifiedAt       DateTime?
  selfieUrl           String?
  bvnVerifiedAt       DateTime?
  bvnProviderResponse Json?
  otpCode             String?
  otpExpiresAt        DateTime?
  aiApprovals         AiApproval[]
  aiQueries           AiQuery[]
  ocrScans            OcrScan[]
  transactions        Transaction[]
  wallet              Wallet?
  pushTokens          PushToken[]

  @@map("users")
}

model Wallet {
  id                   String              @id @default(cuid())
  userId               String              @unique
  balance              Float               @default(0.00)
  currency             String              @default("NGN")
  virtualAccountNumber String?             @unique
  providerId           String?
  providerAccountName  String?
  provider             String?
  bankName             String?
  pin                  String?
  isActive             Boolean             @default(true)
  dailyLimit           Float               @default(100000)
  monthlyLimit         Float               @default(1000000)
  lastTransactionAt    DateTime?
  createdAt            DateTime            @default(now())
  updatedAt            DateTime            @updatedAt
  receivedTransactions WalletTransaction[] @relation("ReceiverWallet")
  sentTransactions     WalletTransaction[] @relation("SenderWallet")
  user                 User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("wallets")
}

model WalletTransaction {
  id                    String                @id @default(cuid())
  amount                Float
  type                  WalletTransactionType
  status                TransactionStatus     @default(PENDING)
  reference             String                @unique
  description           String?
  fee                   Float                 @default(0)
  senderWalletId        String?
  receiverWalletId      String?
  bankAccountId         String?
  providerReference     String?
  providerResponse      Json?
  senderBalanceBefore   Float?
  senderBalanceAfter    Float?
  receiverBalanceBefore Float?
  receiverBalanceAfter  Float?
  metadata              Json?
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  bankAccount           Account?              @relation(fields: [bankAccountId], references: [id])
  receiverWallet        Wallet?               @relation("ReceiverWallet", fields: [receiverWalletId], references: [id])
  senderWallet          Wallet?               @relation("SenderWallet", fields: [senderWalletId], references: [id])

  @@map("wallet_transactions")
}

model Account {
  id                 String              @id @default(cuid())
  accountName        String
  accountNumber      String
  bankName           String
  bankCode           String?
  routingNumber      String?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  fromTransactions   Transaction[]       @relation("FromAccount")
  toTransactions     Transaction[]       @relation("ToAccount")
  walletTransactions WalletTransaction[]

  @@unique([accountNumber, bankCode])
  @@map("accounts")
}

model Transaction {
  id            String            @id @default(cuid())
  amount        Float
  currency      String            @default("NGN")
  description   String?
  reference     String            @unique
  status        TransactionStatus @default(PENDING)
  type          TransactionType
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  userId        String
  fromAccountId String?
  toAccountId   String?
  ocrScanId     String?
  metadata      Json?
  fromAccount   Account?          @relation("FromAccount", fields: [fromAccountId], references: [id])
  ocrScan       OcrScan?          @relation(fields: [ocrScanId], references: [id])
  toAccount     Account?          @relation("ToAccount", fields: [toAccountId], references: [id])
  user          User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("transactions")
}

model OcrScan {
  id            String        @id @default(cuid())
  originalText  String
  cleanedText   String?
  extractedData Json?
  imageUrl      String?
  confidence    Float?
  status        OcrStatus     @default(PROCESSING)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  userId        String
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions  Transaction[]

  @@map("ocr_scans")
}

model AiQuery {
  id         String        @id @default(cuid())
  prompt     String
  response   String?
  model      String        @default("gemini-2.0-flash")
  status     AiQueryStatus @default(PROCESSING)
  structured Json?
  tokens     Int?
  confidence Float?
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  userId     String
  user       User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("ai_queries")
}

model WebhookLog {
  id            String    @id @default(cuid())
  provider      String
  eventType     String
  reference     String
  accountNumber String?
  amount        Float?
  currency      String?
  status        String?
  payload       Json
  processedAt   DateTime?
  processed     Boolean   @default(true)
  walletUpdated Boolean   @default(false)
  transactionId String?
  error         String?
  createdAt     DateTime  @default(now())
  contentHash   String?
  receivedAt    DateTime  @default(now())

  @@unique([reference, provider])
  @@index([contentHash])
  @@map("webhook_logs")
}

model FeeConfiguration {
  id          String   @id @default(cuid())
  feeType     FeeType  @unique
  percentage  Float?
  fixedAmount Float?
  minAmount   Float?
  maxAmount   Float?
  description String?  // Description of the fee configuration
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("fee_configurations")
}

model SystemConfiguration {
  id          String          @id @default(cuid())
  key         SystemConfigKey @unique
  value       String
  description String?
  updatedAt   DateTime        @updatedAt

  @@map("system_configurations")
}

model AiApproval {
  id         String           @id @default(cuid())
  type       AiApprovalType
  entityId   String
  status     AiApprovalStatus @default(PENDING)
  confidence Float?
  reasoning  String?
  reviewedBy String?
  reviewedAt DateTime?
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  userId     String
  user       User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("ai_approvals")
}

model PushToken {
  id           String    @id @default(cuid())
  token        String    @unique  // Expo push token
  deviceId     String?   // Device identifier (optional)
  deviceName   String?   // Device name as set by the user
  platform     String?   // iOS, Android, etc.
  osVersion    String?   // Operating system version
  appVersion   String?   // App version
  buildVersion String?   // App build version
  appOwnership String?   // App ownership (standalone, expo, guest)
  executionEnvironment String? // Execution environment (storeClient, standalone, bareWorkflow)
  isDevice     Boolean?  // Whether running on a physical device
  brand        String?   // Device brand
  manufacturer String?   // Device manufacturer
  isActive     Boolean   @default(true)
  lastUsedAt   DateTime  @default(now())
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  
  // User who owns this token
  userId       String
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@map("push_tokens")
}

enum SystemConfigKey {
  DEFAULT_WALLET_PROVIDER
  DEFAULT_TRANSFER_PROVIDER
  MAINTENANCE_MODE
  KYC_REQUIRED
  AI_AUTO_APPROVE_THRESHOLD
}

enum KycStatus {
  PENDING
  UNDER_REVIEW
  APPROVED
  REJECTED
}

enum AiApprovalType {
  TRANSACTION
  KYC_VERIFICATION
  RISK_ASSESSMENT
}

enum AiApprovalStatus {
  PENDING
  APPROVED
  REJECTED
  MANUAL_REVIEW_REQUIRED
}

enum WalletTransactionType {
  FUNDING
  TRANSFER
  WITHDRAWAL
  REVERSAL
}

enum TransactionStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  REVERSED
}

enum TransactionType {
  TRANSFER
  PAYMENT
  WITHDRAWAL
  DEPOSIT
}

enum OcrStatus {
  PROCESSING
  COMPLETED
  FAILED
}

enum FeeType {
  TRANSFER
  WITHDRAWAL
  FUNDING
  INTERNATIONAL_TRANSFER
  FUNDING_BUDPAY
  FUNDING_SMEPLUG
  FUNDING_POLARIS
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum AiQueryStatus {
  PROCESSING
  COMPLETED
  FAILED
}
